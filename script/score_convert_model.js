export const subjectGroups = new Map([
  ["G001", ["to", "vl", "hh"]],
  ["G002", ["to", "vl", "sh"]],
  ["G003", ["to", "vl", "nv"]],
  ["G004", ["to", "vl", "ls"]],
  ["G005", ["to", "vl", "dl"]],
  ["G006", ["to", "vl", "gd"]],
  ["G007", ["to", "vl", "th"]],
  ["G008", ["to", "vl", "c1"]],
  ["G009", ["to", "vl", "c2"]],
  ["G010", ["to", "vl", "an"]],
  ["G011", ["to", "hh", "sh"]],
  ["G012", ["to", "hh", "nv"]],
  ["G013", ["to", "hh", "ls"]],
  ["G014", ["to", "hh", "dl"]],
  ["G015", ["to", "hh", "gd"]],
  ["G016", ["to", "hh", "th"]],
  ["G017", ["to", "hh", "c1"]],
  ["G018", ["to", "hh", "c2"]],
  ["G019", ["to", "hh", "an"]],
  ["G020", ["to", "sh", "nv"]],
  ["G021", ["to", "sh", "ls"]],
  ["G022", ["to", "sh", "dl"]],
  ["G023", ["to", "sh", "gd"]],
  ["G024", ["to", "sh", "th"]],
  ["G025", ["to", "sh", "c1"]],
  ["G026", ["to", "sh", "c2"]],
  ["G027", ["to", "sh", "an"]],
  ["G028", ["to", "nv", "ls"]],
  ["G029", ["to", "nv", "dl"]],
  ["G030", ["to", "nv", "gd"]],
  ["G031", ["to", "nv", "th"]],
  ["G032", ["to", "nv", "c1"]],
  ["G033", ["to", "nv", "c2"]],
  ["G034", ["to", "nv", "an"]],
  ["G035", ["to", "ls", "dl"]],
  ["G036", ["to", "ls", "gd"]],
  ["G037", ["to", "ls", "th"]],
  ["G038", ["to", "ls", "c1"]],
  ["G039", ["to", "ls", "c2"]],
  ["G040", ["to", "ls", "an"]],
  ["G041", ["to", "dl", "gd"]],
  ["G042", ["to", "dl", "th"]],
  ["G043", ["to", "dl", "c1"]],
  ["G044", ["to", "dl", "c2"]],
  ["G045", ["to", "dl", "an"]],
  ["G046", ["to", "gd", "th"]],
  ["G047", ["to", "gd", "c1"]],
  ["G048", ["to", "gd", "c2"]],
  ["G049", ["to", "gd", "an"]],
  ["G050", ["to", "th", "c1"]],
  ["G051", ["to", "th", "c2"]],
  ["G052", ["to", "th", "an"]],
  ["G053", ["to", "c1", "c2"]],
  ["G054", ["to", "c1", "an"]],
  ["G055", ["to", "c2", "an"]],
  ["G056", ["vl", "hh", "sh"]],
  ["G057", ["vl", "hh", "nv"]],
  ["G058", ["vl", "hh", "ls"]],
  ["G059", ["vl", "hh", "dl"]],
  ["G060", ["vl", "hh", "gd"]],
  ["G061", ["vl", "hh", "th"]],
  ["G062", ["vl", "hh", "c1"]],
  ["G063", ["vl", "hh", "c2"]],
  ["G064", ["vl", "hh", "an"]],
  ["G065", ["vl", "sh", "nv"]],
  ["G066", ["vl", "sh", "ls"]],
  ["G067", ["vl", "sh", "dl"]],
  ["G068", ["vl", "sh", "gd"]],
  ["G069", ["vl", "sh", "th"]],
  ["G070", ["vl", "sh", "c1"]],
  ["G071", ["vl", "sh", "c2"]],
  ["G072", ["vl", "sh", "an"]],
  ["G073", ["vl", "nv", "ls"]],
  ["G074", ["vl", "nv", "dl"]],
  ["G075", ["vl", "nv", "gd"]],
  ["G076", ["vl", "nv", "th"]],
  ["G077", ["vl", "nv", "c1"]],
  ["G078", ["vl", "nv", "c2"]],
  ["G079", ["vl", "nv", "an"]],
  ["G080", ["vl", "ls", "dl"]],
  ["G081", ["vl", "ls", "gd"]],
  ["G082", ["vl", "ls", "th"]],
  ["G083", ["vl", "ls", "c1"]],
  ["G084", ["vl", "ls", "c2"]],
  ["G085", ["vl", "ls", "an"]],
  ["G086", ["vl", "dl", "gd"]],
  ["G087", ["vl", "dl", "th"]],
  ["G088", ["vl", "dl", "c1"]],
  ["G089", ["vl", "dl", "c2"]],
  ["G090", ["vl", "dl", "an"]],
  ["G091", ["vl", "gd", "th"]],
  ["G092", ["vl", "gd", "c1"]],
  ["G093", ["vl", "gd", "c2"]],
  ["G094", ["vl", "gd", "an"]],
  ["G095", ["vl", "th", "c1"]],
  ["G096", ["vl", "th", "c2"]],
  ["G097", ["vl", "th", "an"]],
  ["G098", ["vl", "c1", "c2"]],
  ["G099", ["vl", "c1", "an"]],
  ["G100", ["vl", "c2", "an"]],
  ["G101", ["hh", "sh", "nv"]],
  ["G102", ["hh", "sh", "ls"]],
  ["G103", ["hh", "sh", "dl"]],
  ["G104", ["hh", "sh", "gd"]],
  ["G105", ["hh", "sh", "th"]],
  ["G106", ["hh", "sh", "c1"]],
  ["G107", ["hh", "sh", "c2"]],
  ["G108", ["hh", "sh", "an"]],
  ["G109", ["hh", "nv", "ls"]],
  ["G110", ["hh", "nv", "dl"]],
  ["G111", ["hh", "nv", "gd"]],
  ["G112", ["hh", "nv", "th"]],
  ["G113", ["hh", "nv", "c1"]],
  ["G114", ["hh", "nv", "c2"]],
  ["G115", ["hh", "nv", "an"]],
  ["G116", ["hh", "ls", "dl"]],
  ["G117", ["hh", "ls", "gd"]],
  ["G118", ["hh", "ls", "th"]],
  ["G119", ["hh", "ls", "c1"]],
  ["G120", ["hh", "ls", "c2"]],
  ["G121", ["hh", "ls", "an"]],
  ["G122", ["hh", "dl", "gd"]],
  ["G123", ["hh", "dl", "th"]],
  ["G124", ["hh", "dl", "c1"]],
  ["G125", ["hh", "dl", "c2"]],
  ["G126", ["hh", "dl", "an"]],
  ["G127", ["hh", "gd", "th"]],
  ["G128", ["hh", "gd", "c1"]],
  ["G129", ["hh", "gd", "c2"]],
  ["G130", ["hh", "gd", "an"]],
  ["G131", ["hh", "th", "c1"]],
  ["G132", ["hh", "th", "c2"]],
  ["G133", ["hh", "th", "an"]],
  ["G134", ["hh", "c1", "c2"]],
  ["G135", ["hh", "c1", "an"]],
  ["G136", ["hh", "c2", "an"]],
  ["G137", ["sh", "nv", "ls"]],
  ["G138", ["sh", "nv", "dl"]],
  ["G139", ["sh", "nv", "gd"]],
  ["G140", ["sh", "nv", "th"]],
  ["G141", ["sh", "nv", "c1"]],
  ["G142", ["sh", "nv", "c2"]],
  ["G143", ["sh", "nv", "an"]],
  ["G144", ["sh", "ls", "dl"]],
  ["G145", ["sh", "ls", "gd"]],
  ["G146", ["sh", "ls", "th"]],
  ["G147", ["sh", "ls", "c1"]],
  ["G148", ["sh", "ls", "c2"]],
  ["G149", ["sh", "ls", "an"]],
  ["G150", ["sh", "dl", "gd"]],
  ["G151", ["sh", "dl", "th"]],
  ["G152", ["sh", "dl", "c1"]],
  ["G153", ["sh", "dl", "c2"]],
  ["G154", ["sh", "dl", "an"]],
  ["G155", ["sh", "gd", "th"]],
  ["G156", ["sh", "gd", "c1"]],
  ["G157", ["sh", "gd", "c2"]],
  ["G158", ["sh", "gd", "an"]],
  ["G159", ["sh", "th", "c1"]],
  ["G160", ["sh", "th", "c2"]],
  ["G161", ["sh", "th", "an"]],
  ["G162", ["sh", "c1", "c2"]],
  ["G163", ["sh", "c1", "an"]],
  ["G164", ["sh", "c2", "an"]],
  ["G165", ["nv", "ls", "dl"]],
  ["G166", ["nv", "ls", "gd"]],
  ["G167", ["nv", "ls", "th"]],
  ["G168", ["nv", "ls", "c1"]],
  ["G169", ["nv", "ls", "c2"]],
  ["G170", ["nv", "ls", "an"]],
  ["G171", ["nv", "dl", "gd"]],
  ["G172", ["nv", "dl", "th"]],
  ["G173", ["nv", "dl", "c1"]],
  ["G174", ["nv", "dl", "c2"]],
  ["G175", ["nv", "dl", "an"]],
  ["G176", ["nv", "gd", "th"]],
  ["G177", ["nv", "gd", "c1"]],
  ["G178", ["nv", "gd", "c2"]],
  ["G179", ["nv", "gd", "an"]],
  ["G180", ["nv", "th", "c1"]],
  ["G181", ["nv", "th", "c2"]],
  ["G182", ["nv", "th", "an"]],
  ["G183", ["nv", "c1", "c2"]],
  ["G184", ["nv", "c1", "an"]],
  ["G185", ["nv", "c2", "an"]],
  ["G186", ["ls", "dl", "gd"]],
  ["G187", ["ls", "dl", "th"]],
  ["G188", ["ls", "dl", "c1"]],
  ["G189", ["ls", "dl", "c2"]],
  ["G190", ["ls", "dl", "an"]],
  ["G191", ["ls", "gd", "th"]],
  ["G192", ["ls", "gd", "c1"]],
  ["G193", ["ls", "gd", "c2"]],
  ["G194", ["ls", "gd", "an"]],
  ["G195", ["ls", "th", "c1"]],
  ["G196", ["ls", "th", "c2"]],
  ["G197", ["ls", "th", "an"]],
  ["G198", ["ls", "c1", "c2"]],
  ["G199", ["ls", "c1", "an"]],
  ["G200", ["ls", "c2", "an"]],
  ["G201", ["dl", "gd", "th"]],
  ["G202", ["dl", "gd", "c1"]],
  ["G203", ["dl", "gd", "c2"]],
  ["G204", ["dl", "gd", "an"]],
  ["G205", ["dl", "th", "c1"]],
  ["G206", ["dl", "th", "c2"]],
  ["G207", ["dl", "th", "an"]],
  ["G208", ["dl", "c1", "c2"]],
  ["G209", ["dl", "c1", "an"]],
  ["G210", ["dl", "c2", "an"]],
  ["G211", ["gd", "th", "c1"]],
  ["G212", ["gd", "th", "c2"]],
  ["G213", ["gd", "th", "an"]],
  ["G214", ["gd", "c1", "c2"]],
  ["G215", ["gd", "c1", "an"]],
  ["G216", ["gd", "c2", "an"]],
  ["G217", ["th", "c1", "c2"]],
  ["G218", ["th", "c1", "an"]],
  ["G219", ["th", "c2", "an"]],
  ["G220", ["c1", "c2", "an"]],
]);

export function round2(value, appreciate) {
  let base = Math.pow(10, appreciate);
  value = Math.round(value * base) / base;

  return value;
}

export function getInRangeVal(value, min, max) {
  value = Math.min(value, max);
  value = Math.max(value, min);
  return value;
}

export function getInterpolate(x1, y1, x2, y2, x) {
  if (x1 === x2) return y2;

  return y1 + ((x - x1) / (x2 - x1)) * (y2 - y1);
}

export function getBinSize(min, max, distSize) {
  return (max - min) / (distSize - 1);
}

export function getScore(index, min, max, distSize) {
  return min + index * getBinSize(min, max, distSize);
}

export function getIndex(score, min, max, binCount) {
  return Math.round(((score - min) / (max - min)) * (binCount - 1));
}

export function getCumlative(arr) {
  let ans = new Array(arr.length);

  ans[0] = arr[0];

  for (let i = 1; i < arr.length; i++) ans[i] = ans[i - 1] + arr[i];

  return ans;
}

// distData : {dist : [...], min : float, max : float}

export function getPercentile(value, distData) {
  let cumdist = getCumlative(distData.dist);

  for (let i = 1; i < distData.dist.length; i++) {
    let score1 = getScore(
      i - 1,
      distData.min,
      distData.max,
      distData.dist.length
    );
    let score2 = getScore(i, distData.min, distData.max, distData.dist.length);

    if (score1 <= value && value <= score2) {
      let quan1 = cumdist[i - 1];
      let quan2 = cumdist[i];

      return (
        getInterpolate(score1, quan1, score2, quan2, value) /
        cumdist[cumdist.length - 1]
      );
    }
  }

  if (value < distData.min) return 0;
  else return 1;
}

export function getScoreAtPercentile(per, distData) {
  if (per <= 0) return distData.min;
  else if (per >= 1) return distData.max;

  let cumdist = getCumlative(distData.dist);

  for (let i = 1; i < distData.dist.length; i++) {
    let per1 = cumdist[i - 1] / cumdist[cumdist.length - 1];
    let per2 = cumdist[i] / cumdist[cumdist.length - 1];

    if (per1 <= per && per <= per2) {
      let score1 = getScore(
        i - 1,
        distData.min,
        distData.max,
        distData.dist.length
      );
      let score2 = getScore(
        i,
        distData.min,
        distData.max,
        distData.dist.length
      );

      return getInterpolate(per1, score1, per2, score2, per);
    }
  }

  return distData.max;
}

export function getConvertedScore(firstScore, firstDistData, secDistData) {
  return getScoreAtPercentile(
    getPercentile(firstScore, firstDistData),
    secDistData
  );
}

export function getAddScore(score, addScoreLevel, base) {
  addScoreLevel = Math.min(addScoreLevel, 0.3 * base);

  if (score < 0.75 * base) return addScoreLevel;
  else return ((base - score) / (0.75 * base)) * addScoreLevel;
}

export function getCompleteScore(score, addScoreLevel, base) {
  return score + getAddScore(score, addScoreLevel, base);
}

export async function getDist(supabase, exam, subject, year, base) {
  let ans = { dist: [0, 1, 6, 0], min: 0, max: base };

  let { data, error } = await supabase
    .from("exam_distribution")
    .select("distribution, min, max")
    .eq("method_id", exam)
    .eq("subject_id", subject)
    .eq("year", year);

  if (!error && data && data.length > 0) {
    ans.dist = data[0].distribution;
    ans.min = data[0].min;
    ans.max = data[0].max;
  }

  return ans;
}

export async function getGroupDist(
  supabase,
  exam,
  subjectGroup,
  year,
  eachBase,
  coefs
) {
  function getScoreArr(distData) {
    const arr = [];
    for (let i = 0; i < distData.dist.length; i++) {
      arr.push(getScore(i, distData.min, distData.max, distData.dist.length));
    }
    return arr;
  }

  const subjects = subjectGroups.get(subjectGroup);
  if (!subjects || subjects.length !== 3)
    throw new Error("Invalid subject group");

  const dists = await Promise.all(
    subjects.map((subj) => getDist(supabase, exam, subj, year, eachBase))
  );

  const counts = dists.map((d) => d.dist.reduce((a, b) => a + b, 0));
  const N = Math.min(...counts);

  const pmfs = dists.map((d, idx) => d.dist.map((c) => c / counts[idx]));
  const scoresArr = dists.map((d) => getScoreArr(d));

  const coef1 = coefs[subjects[0]] ?? 1;
  const coef2 = coefs[subjects[1]] ?? 1;
  const coef3 = coefs[subjects[2]] ?? 1;
  const sumCoef = coef1 + coef2 + coef3;

  const maxTheoretical =
    dists[0].max * coef1 + dists[1].max * coef2 + dists[2].max * coef3;

  const step = 0.1;
  const bins = Math.ceil((eachBase * sumCoef) / step);
  const tempDist = new Array(bins).fill(0);
  const min = 0;
  const max = eachBase * sumCoef;

  // Tích chập 3 phổ
  for (let i = 0; i < scoresArr[0].length; i++) {
    const score1 = scoresArr[0][i] * coef1;
    const prob1 = pmfs[0][i];
    for (let j = 0; j < scoresArr[1].length; j++) {
      const score2 = scoresArr[1][j] * coef2;
      const prob2 = pmfs[1][j];
      for (let k = 0; k < scoresArr[2].length; k++) {
        const score3 = scoresArr[2][k] * coef3;
        const prob3 = pmfs[2][k];

        const totalScore = score1 + score2 + score3;

        const idx = getInRangeVal(
          Math.round(((totalScore - min) / (max - min)) * (bins - 1)),
          0,
          bins - 1
        );

        tempDist[idx] += prob1 * prob2 * prob3;
      }
    }
  }

  // Tìm điểm cao nhất sau khi chập (có thí sinh thực tế)
  let lastNonZero = bins - 1;
  while (lastNonZero > 0 && tempDist[lastNonZero] < 1e-6) {
    lastNonZero--;
  }
  const scoreMaxActual = min + (lastNonZero / (bins - 1)) * (max - min);

  // Tính deltaShift = chênh lệch giữa max lý thuyết và thực tế
  const deltaShift = maxTheoretical - scoreMaxActual;

  // Tạo lại dist mới, có thêm dịch chuyển
  const finalDist = new Array(bins).fill(0);
  for (let i = 0; i < scoresArr[0].length; i++) {
    const score1 = scoresArr[0][i] * coef1;
    const prob1 = pmfs[0][i];
    for (let j = 0; j < scoresArr[1].length; j++) {
      const score2 = scoresArr[1][j] * coef2;
      const prob2 = pmfs[1][j];
      for (let k = 0; k < scoresArr[2].length; k++) {
        const score3 = scoresArr[2][k] * coef3;
        const prob3 = pmfs[2][k];

        let totalScore = score1 + score2 + score3 + deltaShift;

        let idx;
        if (Math.abs(totalScore - max) < step / 2) {
          idx = bins - 1;
        } else {
          idx = getInRangeVal(
            Math.round(((totalScore - min) / (max - min)) * (bins - 1)),
            0,
            bins - 1
          );
        }

        finalDist[idx] += prob1 * prob2 * prob3;
      }
    }
  }

  // Power-scaling để nhấn mạnh vùng điểm cao
  function emphasizeUpperTail(dist, gamma = 0.3) {
    const scaled = dist.map((val) => Math.pow(val, gamma));
    const totalBefore = dist.reduce((a, b) => a + b, 0);
    const totalAfter = scaled.reduce((a, b) => a + b, 0);
    const rescaled = scaled.map((val) => val * (totalBefore / totalAfter));
    return rescaled;
  }

  const total = finalDist.reduce((a, b) => a + b, 0);
  const scale = N / total;
  const scaledDist = finalDist.map((x) => x * scale);

  // Hiệu chỉnh độ phân giải vùng trên bằng power-scaling
  const emphasizedDist = emphasizeUpperTail(scaledDist, 0.3); // gamma ∈ (0.1, 0.5)
  const finalRoundedDist = emphasizedDist.map((x) => Math.round(x));

  return {
    min,
    max,
    dist: finalRoundedDist,
  };
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SUBJECT GROUP PROCESSING
////////////////////////////////////////////////////////////////////////////////////////////////////

export function isApplySubject(applySubjects, subject) {
  return !applySubjects.has(subject) || applySubjects.get(subject) !== null;
}

export function hasScoreSubject(subject, scores) {
  return !scores.has(subject) || scores.get(subject) !== null;
}

export function isApplyGroup(applySubjects, subjectGroup) {
  for (let subject of subjectGroups.get(subjectGroup))
    if (!isApplySubject(applySubjects, subject)) return false;

  return true;
}

export function hasScoreGroup(subjectGroup, scores) {
  for (let subject of subjectGroups.get(subjectGroup))
    if (!hasScoreSubject(subject, scores)) return false;

  return true;
}

// subjectGroup : string
// index : int
// coefs : {subject : coef, subject : coef, subject : coef ...}
// scores : Map {subject : [...] / number}

// constraint: scores cant null

export function getGroupScore(subjectGroup, scores, index, coefs) {
  let ans = 0;
  let sumCoefs = 0;

  for (let subject of subjectGroups.get(subjectGroup)) {
    let coef = coefs.hasOwnProperty(subject) ? coefs[subject] : 1;

    sumCoefs += coef;

    if (index !== null) ans += coef * scores.get(subject)[index];
    else ans += coef * scores.get(subject);
  }

  ans = (ans / sumCoefs) * 3;

  return ans;
}

export function getSubjectName(subjectId) {
  switch (subjectId) {
    case "to":
      return "Toán";
    case "vl":
      return "Lý";
    case "hh":
      return "Hóa";
    case "sh":
      return "Sinh";
    case "ls":
      return "Sử";
    case "dl":
      return "Địa";
    case "nv":
      return "Văn";
    case "gd":
      return "GDKTPL";
    case "c1":
      return "CNCN";
    case "c2":
      return "CNNN";
    case "th":
      return "Tin";
    case "an":
      return "Anh";
    default:
      return "Tổng hợp";
  }
}

export function getGroupName(groupId) {
  switch (groupId) {
    case "root":
      return "Gốc";
    case "k00":
      return "K00";
    case "k01":
      return "K01";
    default:
      let subjects = subjectGroups.get(groupId);
      return `${getSubjectName(subjects[0])}-${getSubjectName(
        subjects[1]
      )}-${getSubjectName(subjects[2])}`;
  }
}

export function getMethodeName(methodId) {
  switch (methodId) {
    case "thpt":
      return "TN";
    case "thhb":
      return "HB";
    case "dghn":
      return "HSA";
    case "dgsg":
      return "V-ACT";
    case "vsat":
      return "V-SAT";
    case "dgca":
      return "CAND";
    case "dgsp":
      return "SPT";
    case "dgcb":
      return "H-SCA";
    case "dgtd":
      return "TSA";
    case "hcmut":
      return "HCMUT";
    default:
      return getGroupName(methodId);
  }
}

export function getIndustry1Name(id) {
  switch (id) {
    case 714:
      return "KH giáo dục & đào tạo giáo viên";
    case 721:
      return "Nghệ thuật";
    case 722:
      return "Nhân văn";
    case 731:
      return "KH XH & hành vi";
    case 732:
      return "Báo chí & thông tin";
    case 734:
      return "Kinh doanh & quản lý";
    case 738:
      return "Pháp luật";
    case 742:
      return "KH sự sống";
    case 744:
      return "KH tự nhiên";
    case 746:
      return "Toán & thống kê";
    case 748:
      return "Máy tính & công nghệ thông tin";
    case 751:
      return "Công nghệ kỹ thuật";
    case 752:
      return "Kỹ thuật";
    case 754:
      return "Sản xuất & chế biến";
    case 758:
      return "Kiến trúc & xây dựng";
    case 762:
      return "Nông lâm nghiệp & thủy sản";
    case 764:
      return "Thú y";
    case 772:
      return "Sức khỏe";
    case 776:
      return "Dịch vụ xã hội";
    case 781:
      return "Du lịch khách sạn, thể thao & dịch vụ cá nhân";
    case 784:
      return "Dịch vụ vận tải";
    case 785:
      return "Môi trường & bảo vệ môi trường";
    case 786:
      return "An ninh Quốc phòng";
    default:
      return "Khác";
  }
}

export function getAvg(arr) {
  arr = arr.flat(Infinity);

  if (!arr || arr.length === 0) return 0;
  return arr.reduce((a, b) => a + b, 0) / arr.length;
}

export function getSort(map, index, isAsc) {
  return new Map(
    [...map.entries()].sort((a, b) => {
      const valA = index != null && Array.isArray(a[1]) ? a[1][index] : a[1];
      const valB = index != null && Array.isArray(b[1]) ? b[1][index] : b[1];

      if (valA < valB) return isAsc ? -1 : 1;
      if (valA > valB) return isAsc ? 1 : -1;
      return 0;
    })
  );
}
